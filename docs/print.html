<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Toql book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="1-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="2-concept.html"><strong aria-hidden="true">2.</strong> Concept</a></li><li><a href="3-api/1-introduction.html"><strong aria-hidden="true">3.</strong> Api</a></li><li><ol class="section"><li><a href="3-api/2-load.html"><strong aria-hidden="true">3.1.</strong> Load</a></li><li><a href="3-api/3-query-type.html"><strong aria-hidden="true">3.2.</strong> Query type</a></li><li><a href="3-api/4-insert.html"><strong aria-hidden="true">3.3.</strong> Insert</a></li><li><a href="3-api/5-update.html"><strong aria-hidden="true">3.4.</strong> Update</a></li><li><a href="3-api/6-delete.html"><strong aria-hidden="true">3.5.</strong> Delete</a></li><li><a href="3-api/7-writing-functions.html"><strong aria-hidden="true">3.6.</strong> Writing functions</a></li></ol></li><li><a href="4-derive/1-introduction.html"><strong aria-hidden="true">4.</strong> The Toql derive</a></li><li><ol class="section"><li><a href="4-derive/2-fields.html"><strong aria-hidden="true">4.1.</strong> Fields</a></li><li><a href="4-derive/3-optional-fields.html"><strong aria-hidden="true">4.2.</strong> Optional fields</a></li><li><a href="4-derive/4-sql-expressions.html"><strong aria-hidden="true">4.3.</strong> SQL expressions</a></li><li><a href="4-derive/5-field-handlers.html"><strong aria-hidden="true">4.4.</strong> Field handlers</a></li><li><a href="4-derive/6-joins.html"><strong aria-hidden="true">4.5.</strong> Joins</a></li><li><a href="4-derive/7-join-handlers.html"><strong aria-hidden="true">4.6.</strong> Join handlers</a></li><li><a href="4-derive/8-partial-tables.html"><strong aria-hidden="true">4.7.</strong> Partial tables</a></li><li><a href="4-derive/9-merges.html"><strong aria-hidden="true">4.8.</strong> Merges</a></li><li><a href="4-derive/10-keys.html"><strong aria-hidden="true">4.9.</strong> Keys</a></li><li><a href="4-derive/11-insert.html"><strong aria-hidden="true">4.10.</strong> Insert</a></li><li><a href="4-derive/12-update.html"><strong aria-hidden="true">4.11.</strong> Update</a></li><li><a href="4-derive/13-selections.html"><strong aria-hidden="true">4.12.</strong> Selections</a></li><li><a href="4-derive/14-predicates.html"><strong aria-hidden="true">4.13.</strong> Predicates</a></li><li><a href="4-derive/15-predicate-handlers.html"><strong aria-hidden="true">4.14.</strong> Predicate handlers</a></li><li><a href="4-derive/16-roles.html"><strong aria-hidden="true">4.15.</strong> Roles</a></li><li><a href="4-derive/17-reference.html"><strong aria-hidden="true">4.16.</strong> Reference</a></li></ol></li><li><a href="5-query-language/1-introduction.html"><strong aria-hidden="true">5.</strong> The query language</a></li><li><ol class="section"><li><a href="5-query-language/2-select.html"><strong aria-hidden="true">5.1.</strong> Selecting fields</a></li><li><a href="5-query-language/3-order.html"><strong aria-hidden="true">5.2.</strong> Ordering</a></li><li><a href="5-query-language/4-filter.html"><strong aria-hidden="true">5.3.</strong> Filtering</a></li><li><a href="5-query-language/5-selections.html"><strong aria-hidden="true">5.4.</strong> Selections</a></li><li><a href="5-query-language/6-predicates.html"><strong aria-hidden="true">5.5.</strong> Predicates</a></li></ol></li><li><a href="6-appendix/1-introduction.html"><strong aria-hidden="true">6.</strong> Appendix</a></li><li><ol class="section"><li><a href="6-appendix/2-mysql-enums.html"><strong aria-hidden="true">6.1.</strong> MySQL enums</a></li><li><a href="6-appendix/3-row-access-control.html"><strong aria-hidden="true">6.2.</strong> Row access control</a></li><li><a href="6-appendix/4-serde.html"><strong aria-hidden="true">6.3.</strong> Serde</a></li><li><a href="6-appendix/5-debugging-toql.html"><strong aria-hidden="true">6.4.</strong> Debugging Toql</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Toql book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="bollard-at-the-port.gif" alt="Bollard by the Sea by Gábor Szakács (Public Domain)" /></p>
<a class="header" href="#toql---a-friendly-and-productive-orm" id="toql---a-friendly-and-productive-orm"><h1>Toql - A friendly and productive ORM</h1></a>
<p>Toql is an ORM for async databases that features</p>
<ul>
<li>Translation between Rust structs and database tables.</li>
<li>Can load and modify nested structs.</li>
<li>A unique dead simple query language, suitable for web clients.</li>
<li>Different table aliases from long and readable to tiny and fast.</li>
<li>Prepared statements against SQL injection.</li>
<li>Support for raw SQL for full database power.</li>
<li>Support for role based access.</li>
<li>Highly customizable through user defined parameters, query functions, field handlers, etc.</li>
<li>Compile time safety for queries, fields and path names.</li>
<li>No unsafe Rust code.</li>
<li>Tested on real world scenario.</li>
</ul>
<p>This guide will explain you how to use Toql in your own project.</p>
<p>Toql is free and open source software, distributed under a dual license of MIT and Apache. The code is available on <a href="https://www.github.com/roy-ganz/toql">Github</a>. Check out the API for technical details.</p>
<a class="header" href="#trivia" id="trivia"><h3>Trivia</h3></a>
<ul>
<li>Toql is pronounced <em>to-cue-ell</em> with o as in object.</li>
<li>Toql stands for <em>Transfer Object Query Language</em> and refers to the query language that is unique to this ORM. In a sense though it's a missleading name, because Toql together with Serde effectively avoid the need for data transfer objects (DTO): you pass your model directly.</li>
<li>The project's mascot is a bollard, because Toql pronounced in allemanic / swiss german sounds like <em>Toggel</em>:
A funny word that can colloquially be used for bollards.</li>
</ul>
<a class="header" href="#concept" id="concept"><h1>Concept</h1></a>
<p>Toql is a ORM that aims to boost your developer comfort and speed when working with databases.</p>
<p>To use it you must derive <code>Toql</code> for all structs that represent a table in your database:</p>
<ul>
<li>A field in those structs represents either a columns, an SQL expression or a
relationship to one or many tables.</li>
<li>The field also determines the field name or in case of a relationship the path name in the <a href="5-query-language/1-introduction.html">Toql query</a></li>
</ul>
<p>A struct may map only some columns of a table and also multiple structs may refer to the same table. Structs are rather 'views' to a table.</p>
<p>A derived struct can then be inserted, updated, deleted and loaded from your database. To do that you must call the <a href="3-api/1-introduction.html">Toql API functions</a> with a query string or just a list of fields or paths.</p>
<p>Here the typical flow in a web environment:</p>
<ol>
<li>A web client sends a Toql query to the REST Server.</li>
<li>The server uses Toql to parse the query and to create SQL statements.</li>
<li>Toql sends the SQL to the database</li>
<li>then deserializes the resulting rows into Rust structs.</li>
<li>The server sends these structs to the client.</li>
</ol>
<a class="header" href="#quickstart" id="quickstart"><h2>Quickstart</h2></a>
<p>There is full featured <a href="https://github.com/roy-ganz/todo_rotomy">REST server</a> based on Rocket, Toql and MySQL. It can be used as a playground or starting point for own projects.</p>
<a class="header" href="#the-toql-api" id="the-toql-api"><h1>The Toql API</h1></a>
<p>Toql relies on backends to handle database differences.
These backends implement the <code>ToqlApi</code> trait
which serves as an entry point for any high level function.
The backends internally then use the Toql library to do their job.</p>
<p>This chapter explains how to use the <code>ToqlApi</code> trait.
Notice that you must derive your structs before you can load or modify them
with the <code>ToqlApi</code>. See the <a href="3-api/../4-derive/1-introduction.html">derive chapter</a> for details.</p>
<p>The common <code>ToqlApi</code> trait makes it also possible to write database independend code. This is described <a href="3-api/8-backend-independence.html">here</a>.</p>
<a class="header" href="#creating-the-backend" id="creating-the-backend"><h2>Creating the backend</h2></a>
<p>To use the <code>ToqlApi</code> functions you need a Toql backend and the driver for your database.</p>
<p>Currently the following backends are available</p>
<table><thead><tr><th>Database </th><th> Backend Crate     </th><th> Driver Crate</th></tr></thead><tbody>
<tr><td> MySQL   </td><td> toql_mysql_async</td><td> mysql_async </td></tr>
</tbody></table>
<p>For MySQL add this to your <code>cargo.toml</code>:</p>
<pre><code class="language-toml">[dependency]
toql = &quot;0.3&quot;
toql_mysql_async = &quot;0.3&quot;
</code></pre>
<p>You must add <code>toql</code> together with the backend crate. The backend crate then depends on a suitable version of the driver crate.
Normally there is no need to access the driver crate. However I you really must, the backend crate re-exports the driver crate.
For <code>toql_mysql_async</code> the driver crate can be accessed through <code>toql_mysql_async::mysql_async</code>.</p>
<p>With these two dependencies you can get the backend in your code. Notice that the backend takes
a database connection and a cache object to hold the database mapping.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use mysql_async::MySql;
use toql_mysql_async::prelude::MySqlAsync;
use toql::prelude::Cache;

let pool = mysql_async::Pool::new(database_url);
let mut conn = pool.get_conn().await?;

let cache = Cache::new();

let toql = MySqlAsync::from(&amp;mut conn, &amp;cache);
#}</code></pre></pre>
<p>In a bigger project you may want to feed configuration or authentication values into your SQL.
This is done through so called auxiliary parameters (aux params).</p>
<p>There are three ways to feed in aux params:</p>
<ul>
<li>You can put them in the context and they will be available as long as the
backend object lives</li>
<li>You can also ship them with a query and they will be available only for that query</li>
<li>You can map aux params to a field. Used to configure <a href="3-api/../4-derive/5-field-handlers.html">field handlers</a>.</li>
</ul>
<p>Here how to put them in the context:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use mysql_async::MySql;
use toql_mysql_async::prelude::MySqlAsync;
use toql::prelude::{Cache, ContextBuilder};
use std::collections::HashMap;


let pool = mysql_async::Pool::new(database_url);
let mut conn = pool.get_conn().await?;

let mut p = HashMap::new();
p.insert(&quot;page_limit&quot;.into(), 200.into());

let context = ContextBuilder::new().with_aux_params(p).build();
let cache = Cache::new();
let toql = MySqlAsync::with_context(&amp;mut conn, &amp;cache, context);
#}</code></pre></pre>
<p>Beside aux params <code>ContextBuilder</code> allows you</p>
<ul>
<li>to choose an alias format (<code>user.id</code>, <code>us1.id</code>, <code>t0.id</code>, ...)</li>
<li>set the roles for <a href="3-api/../4-derive/16-roles.html">access control</a></li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::{ContextBuilder, AliasFormat};
use std::collections::HashSet;

let mut roles = HashSet::new();
roles.insert(&quot;teacher&quot;, &quot;admin&quot;);

 let context = ContextBuilder::new()
   .with_alias(AliasFormat::Tiny)
   .with_roles(roles)
   .build();
#}</code></pre></pre>
<a class="header" href="#loading" id="loading"><h2>Loading</h2></a>
<p>There are three loading functions: <code>load_one</code>, <code>load_many</code> and <code>load_page</code>.</p>
<p>All loading functions take a <a href="3-api/../5-query-language/1-introduction.html">Toql query</a> and will translate it into SQL SELECT statement(s). The resulting rows will be deserialized and returned.</p>
<p>If your Toql structs contain a <code>Vec</code> of other structs, the load functions issue multiple SELECT statements and merge the results.</p>
<p>If you expect exactly one result, use <code>load_one</code>.</p>
<pre><code>    use toql::prelude::{query, ToqlApi};

    let toql = ...
    let q = query!(...);
    let u = toql.load_one(q).await?;
</code></pre>
<p>The function will return <code>ToqlError::NotFound</code> if no row matched the query filter or <code>ToqlError::NotUnique</code> if more than one row matched.
To load zero or one row use <code>load_page</code>, see below.</p>
<p>Similarly, if you need to load multiple rows:</p>
<pre><code>    use toql::prelude::{query, ToqlApi};

    let toql = ...
    let q = query!(...);
    let u = toql.load_many(q).await?;
</code></pre>
<p><code>load_many</code> returns a <code>Vec</code> with deserialized rows.
The <code>Vec</code> will be empty, if no row matched the filter criteria.</p>
<p><code>load_page</code> allows you to select a page with a starting point and a certain length.
It returns a <code>Vec</code> and count information.</p>
<p>The count information is either <code>None</code> for an uncounted page
or contains count statistics that is needed for typical pagers in web apps, see below.
(After all Toql was initially created to serve web pages.)</p>
<p>To load the first 10 -or less- rows do this:</p>
<pre><code>    use toql::prelude::{query, ToqlApi, Page};

    let toql = ...
    let q = query!(...);
    let (u, _) = toql.load_page(q, Page::Uncounted(0, 10)).await?;
</code></pre>
<p>To serve a webpage, you may also want to include count informations.</p>
<pre><code>    use toql::prelude::{query, ToqlApi, Page};

    let toql = ...
    let q = query!(...);
    let (u, c) = toql.load_page(q, Page::Counted(0, 10)).await?;
</code></pre>
<p>The code is almost the same, but the different page argument will issue two more select statements
to return the <em>filtered</em> page length and the <em>total</em> page length. Let's see what those are:</p>
<p>Suppose you have a table with books. The books have an id, a title and an author_id.</p>
<table><thead><tr><th>id</th><th>title</th><th> author_id</th></tr></thead><tbody>
<tr><td> 1</td><td> The world of foo</td><td> 1</td></tr>
<tr><td> 2</td><td> The world of bar</td><td> 1</td></tr>
<tr><td> 3</td><td> The world of baz</td><td> 1</td></tr>
<tr><td> 4</td><td> What 42 tells me</td><td> 1</td></tr>
<tr><td> 5</td><td> Flowers And Trees</td><td>2</td></tr>
</tbody></table>
<p>Let's assume we have a webpage that contains a pager with page size <em><strong>2</strong></em> and a pager filter.
The author wants to see all books that contain the word <em><strong>world</strong></em>. What will he get?</p>
<ul>
<li>The first two rows (id 1, id 2).</li>
<li>The <em>filtered page count</em> of 3, because 3 rows match the filter criteria.
The pager can now calculate the number of pages: ceil(3 / 2) = 2</li>
<li>The <em>total page count</em> of 4. The author knows now that with a different filter query, he could
get at most 4 rows back.</li>
</ul>
<p>In practice the <em>total page count</em> is not so straight forward to select:
Toql needs to decide, which filters from the query to consider or ignore when building the count SQL statement.
For the <em>total page count</em> only filters are used on fields that are listed in the special <a href="3-api/../4-derive/9-selections.html">count selection</a> and <a href="3-api/../4-derive/10-predicates.html">predicates</a> that are marked as count filters.</p>
<a class="header" href="#the-query-type" id="the-query-type"><h2>The Query type</h2></a>
<p>All load functions need a query, but how is this build?</p>
<p>The recommended way is to use the <code>query!</code> macro.</p>
<p>Alternatives are</p>
<ul>
<li>to create a new <code>Query&lt;T&gt;</code> object and use its builder methods</li>
<li>or to parse a string</li>
</ul>
<p>This chapter does not explain the Toql query language itself, see <a href="3-api/../5-query-language/1-introduction.html">here</a> to learn about that.</p>
<a class="header" href="#the-query-macro" id="the-query-macro"><h3>The query! macro</h3></a>
<p>The <code>query!</code> macro will compile the provided string into Rust code. Any syntax mistakes, wrong path or field names show up
as compiler errors!</p>
<p>Queries are typesafe, so <code>query!</code> takes a type and a query expression. See here (This assumes a Toql derived User struct):</p>
<pre><code>use toql::prelude::query;
let user_id = 5;
let q = query!(User, &quot;*, id eq ?&quot;,  user_id);
</code></pre>
<p>To include query parameters just insert a question mark in the query string and provide the parameter after the string.</p>
<p>In the example above it would also be possible to put the number 5 directly into the query string, since it's a constant.
The resulting SQL would be the same as Toql extracts the parameter in either case to prevent SQL injections.</p>
<p>The Toql query only works with numbers and strings, see <code>SqlArg</code>.
However this is not be a problem: Since database columns have a type, the database is able convert a string or number into its column type.</p>
<p>It's also possible to include other queries into a query. Consider this:</p>
<pre><code>use toql::prelude::query;
let q1 = query!(User, &quot;id eq ?&quot;, 5);
let q = query!(User, &quot;*, {}&quot;, q1);
</code></pre>
<p>Here we include the query <code>q1</code> into <code>q</code>. Since queries are typesafe, so you can only include queries of the same type.</p>
<a class="header" href="#working-with-keys" id="working-with-keys"><h3>Working with keys</h3></a>
<p>When entities have composite keys or you want to write generic code it's easier to work with keys. Key structs are automatically derived from the <code>Toql</code> derive and are located where the struct is. Keys contain all fields from the struct that are marked with <code>#[toql(key)]</code>.</p>
<p>With a single key this is possible</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::query;

let k = UserKey::from(5); // Easier than UserKey{id:5};
let q1 = query!(User, &quot;id eq ?&quot;, k);
let q2 = query!(User, &quot;*, {}&quot;, Query::from(k));
let q3 = query!(User, &quot;*, {}&quot;, k);
#}</code></pre></pre>
<p>With multiple keys you can do this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::{query, Query};

let ks = vec![UserKey::from(1), UserKey::from(2)];

let q4 = query!(User, &quot;*, id in ?&quot;, ks);

let qk = ks.iter().collect::&lt;Query&lt;_&gt;&gt;();
let q5 = query!(User, &quot;*, {}&quot;, qk);
#}</code></pre></pre>
<p>The query <code>q4</code> only works for a simple key, not a composite key, whereas <code>qk</code> works for any type of key.</p>
<p>If you deal with entities you can get their keys from them (notice the <code>Keyed</code> trait). See here</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::{query, Keyed, Query};

let e = User{id:1};

let q5 =  query!(User, &quot;{}&quot;, e.key())
let q6 =  Query::from(e.key());
#}</code></pre></pre>
<p>Both <code>q5</code> and<code>q6</code> end up the same.</p>
<p>Or with mutiple entities:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::{query, MapKey, Query};

let es = vec![User{id:1}, User{id:2}];

let qk = es.iter().map_key().collect::&lt;Query&lt;_&gt;&gt;();
let q7 = query!(User, &quot;*, {}&quot;, qk);
#}</code></pre></pre>
<p>Do you like the <code>collect</code> style? There is a nifty implementation detail:
If you collect keys, they will always be concatenated with <em>OR</em>, queries however will be concatenated with <em>AND</em>.</p>
<p>Compare <code>q8</code> and <code>q10</code> here:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let ks = Vec[UserKey{id:5}, UserKey{id:6}];
let q8 = ks.iter().collect::&lt;Query&lt;_&gt;&gt;(); // -&gt; query!(User, &quot;(id eq5; id eq 6)&quot;)

let q9 = query!(User, &quot;username&quot;);
let q10 = [q9, q8].iter().collect&lt;Query&lt;_&gt;&gt;(); // -&gt; query!(User, &quot;username, (id eq 5; id eq 6)&quot;)

#}</code></pre></pre>
<a class="header" href="#the-intoquery-trait" id="the-intoquery-trait"><h3>The <code>Into&lt;Query&gt;</code> trait</h3></a>
<p>In the example above the query <code>q3</code> is build with a <code>UserKey</code>. This is possible because <code>UserKey</code> implements <code>Into&lt;Query&lt;User&gt;&gt;</code>.
You can also implement this trait for you own types. Let's assume a book category.</p>
<a class="header" href="#example-1-adding-an-enum-filter-to-the-query" id="example-1-adding-an-enum-filter-to-the-query"><h4>Example 1: Adding an enum filter to the query</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::Query;

enum BookCategory {
    Novel,
    Cartoon
}
impl Into&lt;Query&lt;Book&gt; for BookCategory {
    pub fn info(&amp;self) {
       query!(Book, &quot;category eq ?&quot;, 
       match self {
        Novel =&gt; &quot;NOVEL&quot;,
        Cartoon =&gt; &quot;CARTOON&quot;    
       })
    }
}

#}</code></pre></pre>
<p>Now use it like this</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let q = query!(Book, &quot;*, {}&quot;, BookCategory::Novel);
#}</code></pre></pre>
<a class="header" href="#example-2-adding-an-authorization-filter-to-the-query" id="example-2-adding-an-authorization-filter-to-the-query"><h4>Example 2: Adding an authorization filter to the query</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::{QueryWith, Query, Field}
struct Auth {
    user_id: u64
}
impl Into&lt;Query&lt;Book&gt;&gt; for Auth {
    pub fn into(self) -&gt; Query&lt;Book&gt; {

        // This time with the builder methods for educational reasons
        // In production do this query!(User, &quot;authorId eq ?&quot;, self.user_id)
        Query::from(Book::fields().author_id().eq(self.user_id))
    }
}
#}</code></pre></pre>
<p>You may want trade typesafety for more flexibility. See the example above again, this time with the <code>Field</code> type.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::{ Query, Field}
struct Auth {
    author_id: u64
}
impl&lt;T&gt; Into&lt;Query&lt;T&gt;&gt; for Auth {
    pub fn into(&amp;self) -&gt; Query&lt;T&gt;{
        Query::from(Field::from(&quot;authorId&quot;).eq(self.author_id))
    }
}
#}</code></pre></pre>
<p>Wrong field names in <code>Field::from</code> do not show up at compile time, but at runtime.</p>
<p>You can use both examples like so</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::query;
let auth = Auth {author: 5};
let q = query!(Book, &quot;*, {}&quot;, auth);
#}</code></pre></pre>
<a class="header" href="#the-querywith-trait" id="the-querywith-trait"><h3>The <code>QueryWith</code> trait</h3></a>
<p>The <code>query!</code> macro produces a <code>Query</code> type and can further be altered using all methods from that type.
One interesting method is <code>with</code>. It takes a <code>QueryWith</code> trait that can be implemented for any custom type to enhance the query.
This is more powerful than <code>Into&lt;Query&gt;</code> because you can also access auxiliary parameters.</p>
<p>Aux params can be used in SQL expressions. See <a href="3-api/4-derive/2-sql-expressions.html">here</a> more information.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Config {
    limit_pages: u64
}
impl QueryWith for Config {
    pub fn with(&amp;self, query: Query&lt;T&gt;) {
        query.aux_param(&quot;limit_pages&quot;, self.limit_pages)
    }
}
#}</code></pre></pre>
<p>This can now be used like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::query;
let config = Config {limit_pages: 200};
let k = UserKey::from(5);
let q = query!(User, &quot;*, {}&quot;, k.to_query()).with(config);
#}</code></pre></pre>
<a class="header" href="#parsing-queries" id="parsing-queries"><h3>Parsing queries</h3></a>
<p>Use the query parser to turn a string into a <code>Query</code> type.
Only syntax errors will returns as errors,
wrong field names or paths will be rejected later when using the query.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::prelude::Parser;

let s = &quot;*, id eq 5&quot;;

let q = QueryParser::parse::&lt;User&gt;(s).unwrap();
#}</code></pre></pre>
<a class="header" href="#inserts" id="inserts"><h2>Inserts</h2></a>
<p>There are two insert functions: <code>insert_one</code>, and <code>insert_many</code>.</p>
<p>The are used like so:</p>
<pre><code>use toql::prelude::{ToqlApi, paths};

let u = User {id:0, title: &quot;hello&quot;.to_string(), adress: None};

toql.insert_one(&amp;mut u, paths!(top)).await?;
toql.insert_one(&amp;mut u, paths!(User, &quot;&quot;)).await?;

toql.insert_many(&amp;[&amp;mut u], paths!(top)).await?;
</code></pre>
<p>In the example above the first <code>insert_one</code> will insert <code>u</code> into the database,
load back the generated id and sets it on <code>u</code>.
The second <code>insert_one</code> makes a copy of <code>u</code> and again refreshes its <code>id</code> field.</p>
<p>Optional fields that are <code>None</code> will insert the default value of the database. See <a href="3-api/4-derive/6-insert.html">the mapping</a> for details.</p>
<a class="header" href="#the-paths-macro" id="the-paths-macro"><h3>The paths! macro</h3></a>
<p>The <code>paths!</code> macro compiles a path list. Any invalid path will show up at compile time. The insert functions insert all referenced joins and merges from such a path list.</p>
<p>Let's assume a struct <code>User</code> that has a <code>Vec</code> of <code>books</code> with each book joining a <code>publisher</code>. A path list like <code>paths!(User, &quot;books_publisher&quot;)</code> will</p>
<ul>
<li>insert all fields from <code>User</code>.</li>
<li>if the <code>id</code> of <code>User</code> is marked as <a href="3-api/4-derive/2-keys.html">auto key</a>, Toql will load the generated <code>id</code> from the database and update <code>User</code> and the composite key in <code>books</code>.</li>
<li>insert all fields from the joined <code>publisher</code>.</li>
<li>handle the <code>id</code> of publisher like the one in <code>books</code>.</li>
<li>insert the merged books with the correct composite keys.</li>
</ul>
<p>Cool stuff!</p>
<p>If you only want to insert a <code>publisher</code>, then you must call <code>insert</code> on a <code>publisher</code> object.</p>
<p>The paths in the list may overlap. In the path list <code>paths!(User, &quot;books_publisher, books_printedBy&quot;)</code> <code>book</code> appears twice. No problem it will only be inserted once.</p>
<a class="header" href="#skipping-values" id="skipping-values"><h3>Skipping values</h3></a>
<p>When inserting a struct some fields are excluded</p>
<ul>
<li>Fields that map to an <a href="3-api/2-sql-expressions.html">SQL expression</a></li>
<li>Fields or structs with the atribute <code>skip_mut</code></li>
<li>Joins with custom ON predicate</li>
<li>Merges with custom <a href="3-api/../4-derive/5-merges.html">sql_join</a></li>
</ul>
<a class="header" href="#partial-tables" id="partial-tables"><h3>Partial tables</h3></a>
<p>It is possible to split up a table into multiple tables sharing the same primary key. See <a href="4-derive/4-partial-tables">here</a>.</p>
<p>If a path in the path list refers to a struct that contains joins marked as <code>partial table</code> then these
joins will also be inserted. There is no need to mention these dependencies in the path list.</p>
<a class="header" href="#key-dependencies" id="key-dependencies"><h3>Key dependencies</h3></a>
<p>The order of SQL execution is based on key dependencies between structs.</p>
<a class="header" href="#updates" id="updates"><h2>Updates</h2></a>
<p>There are two update functions: <code>update_one</code> and <code>update_many</code>.</p>
<p>They are used like so:</p>
<pre><code>use toql::prelude::{ToqlApi, fields};

let u = User {id:27, title: &quot;hello&quot;.to_string(), address: None};

toql.update_one(&amp;mut u, fields!(top))?;
toql.update_one(&amp;mut u, fields!(User, &quot;*&quot;))?;

toql.update_many(&amp;[&amp;mut u], fields!(top))?;
</code></pre>
<p>In the example above all three statements do the same.</p>
<a class="header" href="#the-fields-macro" id="the-fields-macro"><h3>The fields! macro</h3></a>
<p>The <code>fields!</code> macro compiles a list of fields. Any invalid path or field name shows up at compile time.</p>
<p>The update function will consider all fields from the field list to update. Optional fields will only
be updated if they contain some value. See <a href="3-api/4-derive/12-update.html">the mapping</a> for details.</p>
<a class="header" href="#joins" id="joins"><h4>Joins</h4></a>
<p>You can update only the foreign key of a join or field from the join. Consider this field list:</p>
<pre><code>let f = fields!(User, &quot;*, address, address_*, address_id&quot;)
</code></pre>
<p>With <code>*</code> we consider all fields from User for updating,
<code>address</code> will update the foreign key to <code>Address</code> in the <code>User</code> table,
<code>address_*</code> will update all simple fields in table <code>Address</code>
and finally <code>address_id</code> is ignored, since keys cannot be updated.</p>
<p>Notice in the example above <code>address</code> is actually a duplicate, because foreign keys are included in <code>*</code>.
It's just mentioned explicitly for the purpose of learning.</p>
<a class="header" href="#merges" id="merges"><h4>Merges</h4></a>
<p>Updates can either</p>
<ul>
<li>update existing structs in a <code>Vec</code></li>
<li>or insert new structs in the <code>Vec</code> and delete removed structs.</li>
</ul>
<p>Consider this field list:</p>
<pre><code>let f = fields!(User, &quot;*, books, books_*&quot;)
</code></pre>
<ul>
<li>With <code>*</code> we consider all simple fields from User for updating (this excludes merges),</li>
<li><code>books</code> resizes the <code>Vec</code>: It deletes all books that are linked to the user but are not found in the <code>books</code> vector and
it inserts new book (toghether with possible <a href="3-api/../4-derive/8-partial-tables.html">partial joins</a>).</li>
<li><code>books_*</code> will update all simple fields in the existing <code>books</code>.</li>
</ul>
<a class="header" href="#example-updating-a-vec-with-new-items" id="example-updating-a-vec-with-new-items"><h3>Example: Updating a Vec with new items.</h3></a>
<pre><code>    #[derive(Debug, PartialEq, Toql)]
    struct Book {
        #[toql(key)]
        id: u64,
        #[toql(key)]
        user_id: u64,
        title: Option&lt;String&gt;
    }

    #[derive(Debug, PartialEq, Toql)]
     #[toql(auto_key = true)]
    struct User {
        #[toql(key)]
        id: u64,
        name: Option&lt;String&gt;,
        #[toql(merge())]
        books : Option&lt;Vec&lt;Book&gt;&gt;
    }

    let u = User {
        id: 27,
        title: Some(&quot;Joe Pencil&quot;),
        books: Some(vec![
            Book{
                id: 100,
                user_id: 0,  // Invalid key
                title: Some(&quot;King Kong&quot;.to_string())
            },
            Book{
                id: 200,
                user_id: 27,
                title: Some(&quot;Batman&quot;.to_string())
            }
        ])
    }

    toql.update_one(&amp;mut u, fields!(&quot;*, books, books_*&quot;)).await?;
    
</code></pre>
<p>To mark new books, add them with an invalid key. A value of <code>0</code> or an empty string <code>''</code> is considered invalid.
Normally databases start counting indexes from 1 and some databases consider an empty string like null, which is
also forbidden as primary key. So this idea of invalid key should normally work, however check with you database.</p>
<p>In rare cases where this does not work. Insert and delete your <code>Vec</code> manually, using the <code>ToqlApi</code> functions.</p>
<p>In the example above the first book has an invalid composite key (<code>id</code>, <code>user_id</code>), because <code>user_id</code> is <code>0</code>.
Toql will notice that and insert a new book (with the correct <code>user_id</code> of <code>27</code>). From the second book with <code>id 200</code> the field <code>title</code> will be updated.</p>
<a class="header" href="#deletes" id="deletes"><h2>Deletes</h2></a>
<p>There are two delete functions: <code>delete_one</code>, and <code>delete_many</code>.</p>
<p>Both functions take a predicate and delete all rows that match that predicate.</p>
<p><code>delete_one</code> takes a key or entity. It will build a filter predicate from that and delete the row that coresponds to the key.</p>
<p><code>delete_many</code> builds a predicate from the filters of the <code>Query</code> argument. Field filters and predicates and considered, where as field selects and selections in the query are ignored. See the <a href="3-api/5-query-lanuage/1-introduction.html">query language</a> for details.</p>
<pre><code>use toql::prelude::ToqlApi;

toql.delete_one(UserKey::from(5))?;

let u = User {id: 5};
toql.delete_one(u).await?;

toql.delete_many(query!(User, &quot;id eq 5&quot;)).await?;
</code></pre>
<a class="header" href="#cascading" id="cascading"><h3>Cascading</h3></a>
<p><code>delete</code> does not do any cascading by itself. It just deletes rows from a <em>single</em> table.
To cascade your deletes you must configure your database relations
and tell the database what to do with your joined rows: Delete them too or just set the foreign key to NULL.</p>
<p>Check the manual for</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html">MySQL</a></li>
<li><a href="https://www.postgresql.org/docs/8.2/ddl-constraints.html#DDL-CONSTRAINTS-FK">Postgres</a></li>
</ul>
<a class="header" href="#writing-functions" id="writing-functions"><h2>Writing functions</h2></a>
<p>In bigger projects you need to structure your code with functions.</p>
<p>There as two common ways, each with different tradeoffs</p>
<ul>
<li>Pass the database driver to the function</li>
<li>Pass ToqlApi to the function</li>
</ul>
<a class="header" href="#passing-the-database" id="passing-the-database"><h3>Passing the database</h3></a>
<p>If you decide to pass the database you give up on database independence, but less trait bounds are needed:</p>
<p>For MySQL this looks like this:</p>
<p>``rust
use toql::prelude::ToqlApi;
use toql_mysql_async::prelude::{MySqlAsync, Queryable};
fn do_stuff<C>(toql: &amp;mut MySqlAsync&lt;'_,C&gt;)
where C:Queryable -&gt; Resulty
{
let q = query!(...)
let users = toql.load_many(&amp;q).await?;
toql.insert_many(users, paths!(top)).await?;
toql.update_many(users, fields!(top)).await?;
toql.delete_many(q).await?;
}</p>
<pre><code>The `Queryable` trait makes the `MySqlAsync` work with a connection or a transaction.



## Database independed functions

It's also possible to pass a struct that implements `ToqlApi`. 
However this requires more trait bounds to satisfy the bounds on `ToqlApi`.
Unfortunately rust Rust compiler has a problem with [associated type bounds](https://rust-lang.github.io/rfcs/2289-associated-type-bounds.html), so it looks more complicated than it had to be.








</code></pre>
<a class="header" href="#the-toql-derive" id="the-toql-derive"><h1>The Toql derive</h1></a>
<p>A struct must derive <code>Toql</code>. Only on a derived struct any function from the <a href="4-derive/../3-api/1-introduction.html">ToqlApi</a> can be called.</p>
<p>This derive builds <em>a lot</em> of code. This includes</p>
<ul>
<li>Mapping of Toql fields to struct fields and database columns or expressions.</li>
<li>Creating field methods for the query builder.</li>
<li>Handling relationships through joins and merges.</li>
<li>Creating Key structs.</li>
</ul>
<a class="header" href="#example" id="example"><h2>Example</h2></a>
<p>With this simple code</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
   #[derive(Toql)]
   struct User {
       #[toql(key)]
       id: u32,
       name: Option&lt;String&gt;
}
#}</code></pre></pre>
<p>We can now do the following</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use toql::mysql::load_one; // Load function from derive
use toql::mysql::update_one; // Update function from derive

let toql = --snip--
let cache = 

let q = query!(User, &quot;id eq 5&quot;); 
let mut user = toql.load_one(&amp;q); 

user.age = Some(16);
toql.update_one(&amp;mut user); 
#}</code></pre></pre>
<a class="header" href="#fields" id="fields"><h1>Fields</h1></a>
<p>Struct fields are mapped to Toql query fields and database columns by default in a predictable way:</p>
<ol>
<li>Table names are UpperCamelCase.</li>
<li>Column names are snake_case.</li>
<li>Toql query fields are lowerCamelCase.</li>
<li>Toql query paths are lowerCamelCase, separated with an underscore.</li>
</ol>
<a class="header" href="#renaming-tables-and-columns" id="renaming-tables-and-columns"><h2>Renaming tables and columns</h2></a>
<p>To adjust the default naming to an existing database scheme use the attributes <code>tables</code> and <code>columns</code> for a renaming scheme or <code>table</code> and <code>column</code> for explicit name.</p>
<p>Supported renaming schemes are</p>
<ul>
<li>CamelCase</li>
<li>snake_case</li>
<li>SHOUTY_SNAKE_CASE</li>
<li>mixedCase</li>
</ul>
<a class="header" href="#renaming-scheme-example" id="renaming-scheme-example"><h4>Renaming scheme example</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(tables=&quot;SHOUTY_SNAKE_CASE&quot;, columns=&quot;UpperCase&quot;)]
struct User {
    #[toql(key)]
    user_id: u32
    full_name: String,
}
#}</code></pre></pre>
<p>is translated into</p>
<p><code>SELECT t0.UserId, t0.FullName FROM USER_REF t0</code></p>
<a class="header" href="#explicit-naming-example" id="explicit-naming-example"><h4>Explicit naming example</h4></a>
<p>Use <code>table</code> an the struct and <code>column</code> on the fields to set a name.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(table=&quot;User&quot;)]
struct UserRef {

    #[toql(key, column=&quot;id&quot;)]
    user_id: u32,

    full_name: String,
}
#}</code></pre></pre>
<p>is translated into</p>
<p><code>SELECT t0.id, t0.full_name FROM User t0</code></p>
<p>Use <code>column</code> also when mapping a field, that is a SQL keyword. Notice the back ticks:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[toql(column=&quot;`order`&quot;)]
    order: u32,
#}</code></pre></pre>
<a class="header" href="#toql-query-fields" id="toql-query-fields"><h3>Toql query fields</h3></a>
<p>Toql query fields on a struct are always mixed case, while dependencies are separated with an underscore.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(table=&quot;User&quot;)]
struct UserRef {

    #[toql(key, column=&quot;id&quot;)]
    id: u32

    full_name: String,

    #[toql(join())]
    county: Country
}
#}</code></pre></pre>
<p>is referred to as</p>
<p><code>id, fullName, country_id</code></p>
<a class="header" href="#exclusion" id="exclusion"><h2>Exclusion</h2></a>
<p>Fields can be excluded in several ways</p>
<ul>
<li><code>skip</code> excludes a field completely from the table, use for non-db fields.</li>
<li><code>skip_mut</code> ensures a field is never updated, automatically added for keys and SQL expressions.</li>
<li><code>skip_wildcard</code> removes a field from default <a href="4-derive/../5-query-language/2-select.html">wildcard selection</a>, use for expensive SQL expressions or soft hiding.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(table=&quot;User&quot;)]
struct UserRef {
    
    #[toql(key, column=&quot;id&quot;)]
    id: u32

    full_name: String,

    #[toql(skip_wildcard)]
    middle_name: String,

    #[toql(skip)]
    value: String,

    #[toql(join(), skip_mut)]
    country: Country
}
#}</code></pre></pre>
<a class="header" href="#optional-fields" id="optional-fields"><h1>Optional fields</h1></a>
<p>A <a href="4-derive/../5-query-language/1-introduction.html">Toql query</a> can select individual fields from a struct. However fields must be <code>Option</code> for this, otherwise they will always be selected in the SQL statement, regardless of the query.</p>
<a class="header" href="#example-1" id="example-1"><h3>Example:</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
  #[derive(Toql)]
    struct User {

        #[toql(key)]
        id: u32,			// Always selected in SQL (keys must not be optional)

        age: u8,			// Always selected in SQL

        firstname: Option&lt;String&gt;	// Selectable field of non nullable column
        middlename: Option&lt;Option&lt;String&gt;&gt;// Selectable field of nullable column

        #[toql(preselect)]	
        lastname: Option&lt;String&gt;	// Always selected in SQL, nullable column
  }
#}</code></pre></pre>
<p>You noticed it: Nullable columns that should always be selected must be annotated with <code>preselect</code>.</p>
<a class="header" href="#preselection-and-joins" id="preselection-and-joins"><h2>Preselection and joins</h2></a>
<p>Preselected fields on <em>joined</em> structs are selected, if</p>
<ul>
<li>A join itself is preselected</li>
<li>or at least one field on that join is selected</li>
</ul>
<a class="header" href="#preselection-example" id="preselection-example"><h4>Preselection example</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
  #[derive(Toql)]
    struct User {

        #[toql(key)]
        id: u32,

        #[toql(join())]
        native_language: Language,	// Preselected inner join

        #[toql(join())]
        foreign_language: Option&lt;Option&lt;Language&gt;&gt;,
    }

    #[derive(Toql)]
    struct Language {
            #[toql(key)]
            id: u32,

            code: Option&lt;String&gt;
    }
#}</code></pre></pre>
<p>Above <code>id</code> in <code>User</code> is always selected, because it's <em>not</em> <code>Option</code>.
As <code>native_language</code> is a preselected (inner) join, its <code>id</code> will also always be selected.
But on the contrary <code>foreign_language</code> is a selectable (left) join. <code>id</code> will only be selected if the query requests any other field from that join. For example with <code>foreignLanguage_code</code>.</p>
<a class="header" href="#preselection-on-parent-paths" id="preselection-on-parent-paths"><h2>Preselection on parent paths</h2></a>
<p>One more thing: If a field on a related struct is selected, all preselected fields from the path line will be selected too.</p>
<p>Lets assume we have a <em>user</em> that has an <em>address</em>, which contains <em>country</em> information.</p>
<p>The query</p>
<pre><code class="language-toql">address_country_code
</code></pre>
<p>would therefore</p>
<ul>
<li>select <code>code</code> from the table <code>Country</code></li>
<li>select all preseleted fields from table <code>Country</code></li>
<li>select all preseleted fields from table <code>Address</code></li>
<li>select all preseleted fields from table <code>User</code></li>
</ul>
<a class="header" href="#sql-expressions" id="sql-expressions"><h1>SQL expressions</h1></a>
<p>Toql is an SQL friendly ORM. Instead of mapping a struct field to a column you can also map it
to a raw SQL expression. There are small syntax enhancements to work with aliases and auxiliary parameters.</p>
<a class="header" href="#alias-axample" id="alias-axample"><h4>Alias axample</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
struct User {
    #[toql(key)]
    id: u64,

    #[toql(sql=&quot;(SELECT COUNT(*) FROM Books b WHERE b.author_id = ..id)&quot;)]
    number_of_book:u64
}
#}</code></pre></pre>
<p>Notice the <code>..</code> ! This special alias will be replaced with the alias crated for <em>User</em>.
The generated SELECT might look like this:</p>
<pre><code>SELECT t0.id, (SELECT COUNT(*) FROM Books WHERE author_id = t0.id) FROM User t0
</code></pre>
<p>To use aux params in a SQL query use the <code>&lt;param_name&gt;</code> syntax.</p>
<a class="header" href="#aux-params-example" id="aux-params-example"><h4>Aux params example</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
struct User {
    #[toql(key)]
    id: u64,

    #[toql(sql=&quot;(SELECT &lt;page_limit&gt;)&quot;)]
    page_limit:u64

     #[toql(sql=&quot;(SELECT COUNT(*) FROM Films f WHERE f.age &gt;= &lt;age&gt;)&quot;)]
    age_rated_films:u64
}
#}</code></pre></pre>
<p>In the example <em>page_limit</em> might come from a server configuration.
It would typically be put in the <a href="4-derive/../3-api/1-introduction.html">context</a> and can be used in SQL expressions.</p>
<p>The aux param <em>age</em> might be taken from the authorisation token and put as an aux param into the context or query.
Here it restricts the number of films.</p>
<a class="header" href="#other-uses-of-raw-sql" id="other-uses-of-raw-sql"><h2>Other uses of raw SQL</h2></a>
<p>There are other places you can use raw SQL:</p>
<ul>
<li><a href="4-derive/10-predicates.html">Predicates</a></li>
<li><a href="4-derive/5-merges">Custom Merge</a></li>
</ul>
<a class="header" href="#field-handlers" id="field-handlers"><h1>Field handlers</h1></a>
<p>It's possible to write an own field handler. Do it, because</p>
<ul>
<li>You want to build an SQL expression with a function.</li>
<li>You want to support a database function through <a href="4-derive/../5-query-language/4-filter.html"><code>FN</code></a></li>
<li>You want to abuild a filter condition with a function</li>
</ul>
<a class="header" href="#filter-on-fields" id="filter-on-fields"><h2>Filter on fields</h2></a>
<p>Let's support a length function <code>LLE</code> , so that we can filter on maximum  word length</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
use toql::prelude::{BasicFieldFilter, FieldHandler, SqlExpr, SqlBuilderError, FieldFilter};

struct LengthFieldHandler{
    // The default field handler gives us default filters, such as `eq`, `ne`, ...
    default_handler: BasicFieldHandler, 
};

impl FieldHandler for PermissionFieldHandler
{
    fn build_filter(
       &amp;self,
       select: SqlExpr,        // Our column or SQL expression
       filter: &amp;FieldFilter,   // The filter called with this field
       aux_params: &amp;ParameterMap, // All aux params available
   ) -&gt; Result&lt;Option&lt;SqlExpr&gt;, SqlBuilderError&gt; {
       match filter {
           // Support our custom LL filter that maps to the MySQL FIND_IN_FIELD function
           FieldFilter::Fn(name, args) =&gt; match name.as_str() {
               &quot;LLE&quot; =&gt; {
                    if args.len() != 1 {
                       return Err(SqlBuilderError::FilterInvalid( &quot;filter `FN LLE` expects exactly 1 argument&quot;.to_string()));
                   }
                   Ok(Some(sql_expr!(&quot;LENGTH ({}) &lt;= ?&quot;, select, args[0])))
               }
               name @ _ =&gt; Err(SqlBuilderError::FilterInvalid(name.to_string())),
           },
           _ =&gt; self.default_handler.build_filter(select, filter, aux_params),
       }
   }

}

// Getter method for mapper
pub fn length_field_handler() -&gt; impl FieldHandler {
   LengthFieldHandler:{
        default_handler: BasicFieldHandler::new(), 
   }
}
#}</code></pre></pre>
<p>Now we can map our filter with</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[toql(handler=&quot;length_field_handler&quot;)]
name: String
#}</code></pre></pre>
<p>and use it in a query with</p>
<pre><code class="language-toql">*, name FN LLE 5
</code></pre>
<p>For a bigger example, check out our <a href="4-derive/6-appendix/4-row-access-control.html">permission handler</a>.</p>
<a class="header" href="#field-handlers-with-local-aux-params" id="field-handlers-with-local-aux-params"><h3>Field handlers with local aux params</h3></a>
<p>If you want to use the same field handler in different places
it mightly come handy to give the field handler some local context.</p>
<p>This can be achieved with local aux_params:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[toql(sql=&quot;&quot;, field_handler=&quot;smart_name_handler&quot;, aux_param(name=&quot;strategy&quot;, value=&quot;quick&quot;))]
    smart_name: String
#}</code></pre></pre>
<p>The aux param <code>strategy</code> is only available in the <code>smart_name_handler</code>. Only strings values are supported.</p>
<a class="header" href="#joins-1" id="joins-1"><h1>Joins</h1></a>
<p>A struct can refer to another struct. This is done with a SQL join.</p>
<p>Joins are added to the SQL statement when</p>
<ul>
<li>requested in the query, like so: <code>phone1_id</code></li>
<li>or joins are preselected.</li>
</ul>
<a class="header" href="#join-mapping-example" id="join-mapping-example"><h4>Join mapping example</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
struct User {

    #[toql(key)]
     id: u32,	

     name: Option&lt;String&gt;

     #[toql(join())]  
     phone1 : Phone // Always selected inner join

     #[toql(join())]  
     phone2 : Option&lt;Phone&gt; // Selectable inner join

     #[toql(join())]  
     phone3 : Option&lt;Option&lt;Phone&gt;&gt; // Selectable left join

     #[toql(join(), preselect)]  
     phone4 : Option&lt;Phone&gt; // Always selected left join
}
#}</code></pre></pre>
<p>Notice how <code>Option</code> makes the difference between an inner join and a left join.</p>
<a class="header" href="#renaming-joined-columns" id="renaming-joined-columns"><h2>Renaming joined columns</h2></a>
<p>By default foreign keys are calulated by the primary columns of the join and the field name of the join.
For the above it would be <em>phone1_id</em>, <em>phone2_id</em>, <em>phone3_id</em> and <em>phone4_id</em>.</p>
<p>If your naming scheme differs from that default behaviour, use the <code>columns</code> attribute:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[toql(join(columns(self=&quot;mobile1_id&quot;, other=&quot;id&quot;)))]  
phone1 : Phone 
#}</code></pre></pre>
<p>For a composite key use <code>columns</code> multiple times.</p>
<a class="header" href="#custom-on-predicate" id="custom-on-predicate"><h2>Custom ON predicate</h2></a>
<p>It's possible to restrict the join with a <code>ON</code> SQL predicate.</p>
<p>Here an example of a translated country name.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
struct User {

    #[toql(key)]
     id: u32,	

     country: Option&lt;Country&gt;
}

#[derive(Toql)]
#[toql(auto_key = false))]
struct Country {

    #[toql(key)]
     id: u32,	

    #[toql(join(columns(self = &quot;id&quot;, other = &quot;id&quot;), 
            on_sql = &quot;...language_id=&lt;interface_language_id&gt;&quot;
        ),
    )]
    pub translation: Option&lt;CountryTranslation&gt;
}
#[derive(Toql)]
#[toql(auto_key = false))]
pub struct CountryTranslation {

    #[toql(key)]
    pub id: String,
    
    pub title: String,
}
#}</code></pre></pre>
<p>You can use any raw SQL in the <code>ON</code> predicate. Did you spot the <code>...</code> alias?
This will resolve to the alias of the joined struct (CountryTranslation).</p>
<p>Apart from <code>ON</code> predicates the <code>...</code> alias can also be used in custom merge predicates.</p>
<p>It is also possible to use the regular <code>..</code> alias to refer to the joining struct (Country), but we don't need it here.</p>
<p>You can use auxiliary parameters (here <em>&lt;interface_language_id&gt;</em>) in <code>ON</code> expression.
Aux params usually come from a context, query.</p>
<p>However for <code>ON</code> there is a third source : Aux params may also come from <a href="4-derive/10-predicates.html">query predicates</a>.</p>
<p>This allows some nifty joining, see here:</p>
<a class="header" href="#example-with-on_aux_param" id="example-with-on_aux_param"><h3>Example with on_aux_param</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
#[derive(Toql)]
#[toql(auto_key = false, 
        predicate(
            name =&quot;language&quot;, 
            sql=&quot;EXISTS(SELECT 1 FROM Country c \
                JOIN Language l ON (c.id= l.id)) WHERE l.id= ?)&quot;, 
            on_aux_param=&quot;language_id&quot;
        ))]
struct Country {

    #[toql(key)]
     id: u32,	

    #[toql(join(columns(self = &quot;id&quot;, other = &quot;country_id&quot;), 
            on_sql = &quot;...id=&lt;language_id&gt;&quot;
        ),
    )]
    pub language: Option&lt;Language&gt;
}

#[derive(Toql)]
#[toql(auto_key = false))]
pub struct Language {

    #[toql(key)]
    pub id: String,
    
    pub title: String,
}
#}</code></pre></pre>
<p>Above we add a predicate that allows to filter all countries by a language.
There can be multiple countries that speak the same language.</p>
<p>The predicate takes the one argument (<code>?</code>) and adds it to the aux_params for custom joins (<code>on_param</code>).</p>
<p>When the predicate is used in a Toql query, lets say  <code>*, @language 'fr'</code> the SQL will return  countries that speak french.
In addition it will add <code>fr</code> to the aux_params when doing the custom join.</p>
<p>So each country will contain the <code>language</code> field with information about french.</p>
<p>It's somehow hacky, but it works and is useful in 1-n situations when you want 1-1 .</p>
<a class="header" href="#insert--update-implications" id="insert--update-implications"><h2>Insert / update implications</h2></a>
<p>Toql can insert joins with renamed columns and no custom <code>ON</code> expression,
because key propagation is done internally through common column names.
Joins with custom <code>ON</code> expressions can't be inserted or updated, they are read only.</p>
<a class="header" href="#the-join-struct" id="the-join-struct"><h2>The Join struct</h2></a>
<p>Joining directly another struct is not ergonomic when you want to update the struct.
Thats why the <code>Join</code> enum exists. It can either take a struct value or just its key.</p>
<p>Consider this</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
struct User {

    #[toql(key)]
     id: u32,	

    #[toql(join())]
     phone: Phone
}
#}</code></pre></pre>
<p>Here when we want to set a new <code>Phone</code> for the user, we need to provide a full <code>Phone</code> struct
even tough we only want to set a new value for the foreign key <code>phone_id</code> in <code>User</code>.
This feels unnesseary and <code>toql::prelude::Join</code> comes to our rescue:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
struct User {

    #[toql(key)]
     id: u32,	

    #[toql(join())]
     phone: Join&lt;Phone&gt;

     #[toql(join())]
     phone2: Option&lt;Option&lt;Join&lt;Phone&gt;&gt;&gt;
}
#}</code></pre></pre>
<p>This has the following advantages:</p>
<ul>
<li>Loads as normal, <code>Join</code> will always hold a full value.</li>
<li>Updating the <code>phone_id</code> column in User requires only a <code>PhoneKey</code>.
This key can be always be taken out from <code>Join</code>.</li>
<li>Web clients can send in keys or full entities. <code>Join</code> will deserialize into whatever is possible.</li>
</ul>
<p>For working with joins in your code checkout the <code>toql::prelude::join!</code> or <code>toql::prelude::rval_join!</code> macros.</p>
<a class="header" href="#sidenote-for-sql-generation" id="sidenote-for-sql-generation"><h2>Sidenote for SQL generation</h2></a>
<p>If you watch the generated SQL joins, you will notice that JOIN statements look slightly more complicated from Toql than you may expect.</p>
<p>This is because Toql builds correctly nested JOIN statements that reflect the dependencies among the joined structs. Any SQL builder that simply concatenates inner joins and left joins may accidentally turn left joins into inner joins. This database behaviour is not well known and usually surprises users - Toql avoids this.</p>
<a class="header" href="#join-handlers" id="join-handlers"><h1>Join handlers</h1></a>
<p>When doing a join, it's possible do write a custom handler.
The handler can only build a custom ON predicate.</p>
<p>Why would you do it? I don't know :)</p>
<p>In all cases I can think of you get your <code>ON</code> predicate cheaper with <a href="4-derive/7-joins.html">on_sql</a>.</p>
<p>However it's still possible:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
use toql::prelude::{JoinHandler, SqlExpr, SqlArg, ParameterMap, SqlBuilderError};

pub(crate) struct MyJoinHandler;

impl JoinHandler for MyJoinHandler {
    fn build_on_predicate(&amp;self, on_predicate: SqlExpr, aux_params: &amp;ParameterMap,)
     -&gt;Result&lt;Option&lt;SqlExpr&gt;, SqlBuilderError&gt; {
     
      Some(on_expr) 
     }
}

// Getter function
pub fn my_join_handler() -&gt; impl JoinHandler {
    MyJoinHandler {}
}
#}</code></pre></pre>
<p>Now map the getter function with</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[toql(join(), handler=&quot;my_join_handler&quot;)]
address: Address
#}</code></pre></pre>
<p>And any join on <code>Address</code> will now call the join handler.</p>
<a class="header" href="#partial-tables-1" id="partial-tables-1"><h1>Partial tables</h1></a>
<p>A database table may split into several tables sharing the same primary key.
This is done because</p>
<ul>
<li>the original table got too many columns</li>
<li>A group of columns in the table is optional</li>
<li>You want to control access  with Toql roles.</li>
</ul>
<p>Partial tables are supported with joins.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
#[derive(Toql)]
#[toql(auto_keys= true)]
struct Question {
    #[toql(key)]
    id: u64

    text: String,

    #[toql(join(columns(self=&quot;id&quot;, other=&quot;question_id&quot;)), partial_table)]
    details: Option&lt;QuestionDetails&gt;
}

#[derive(Toql)]
struct QuestionDetails {
    #[toql(key)]
    question_id: u64
    
    font: String
}
#}</code></pre></pre>
<p>In the example above <code>Question</code> and <code>QuestionDetails</code> share the same values for primary keys.This is what  <code>patial_table</code> says.
So for a <em>question</em> with <em>id = 42</em> there is a <em>question_details</em> with <em>question_id = 42</em>.</p>
<p>Inserts will always insert all partial tables too, whenever a path list asks to insert the base table (Question).</p>
<p>Also it will avoid to insert a non existing foreign key: If <code>QuestionDetails</code> was regular join (without <code>partial_table</code>)
insert would try to set a (non existing) column <code>details_id</code> with the value of the primary key of <code>Questiondetails</code>.
This would be correct for regular joins, but fails on partial tables.</p>
<p>Updates have the same behaviour when inserting new merges and for loading <code>partial_table</code> has no effect.</p>
<a class="header" href="#merges-1" id="merges-1"><h1>Merges</h1></a>
<p>A struct can contain a <code>Vec</code> of other structs. Because this can't be loaded directly in SQL, Toql will execute multiple queries and merge the results.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(auto_key = true)]
struct User {

    #[toql(key)]
     id: u32,

     name: Option&lt;String&gt;

     #[toql(merge())]  
     mobile_phones : Vec&lt;Phone&gt;
}

#[derive(Toql)]
struct Phone {

    #[toql(key)]
    number: Option&lt;String&gt;

    prepaid : Option&lt;bool&gt;
}
#}</code></pre></pre>
<p>Selecting all fields from above with <code>*, mobilePhones_*</code> will run 2 SELECT statements and merge the resulting <code>Vec&lt;Phone&gt;</code> into <code>Vec&lt;User&gt;</code> by the common value of <code>User.id</code> and <code>Phone.user_id</code>.</p>
<a class="header" href="#renaming-merge-columns" id="renaming-merge-columns"><h2>Renaming merge columns</h2></a>
<p>By default the merge column names follow the pattern above. However it's possible to explicitly specify the column names:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[toql(merge(columns(self=&quot;id&quot;, other=&quot;user_id&quot;)))]  
phones : Vec&lt;Phone&gt;
#}</code></pre></pre>
<a class="header" href="#no-association-table-with-join_sql" id="no-association-table-with-join_sql"><h2>No association table with <code>join_sql</code></h2></a>
<p>Often in a 1-n-1 situation the association table (n) does not contain any other columns apart
from the composite key. In those situations it's often desirable to skip it.</p>
<p>Let's go with an example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(auto_key = true)]
struct User {

    #[toql(key)]
    id: u32,

    name: Option&lt;String&gt;

    #[toql(merge()))] // Default merging on User.id = UserCountry.user_id
    countries1 : Vec&lt;UserCountry&gt;

     #[toql(merge(
        join_sql = &quot;JOIN UserCountry uc ON (...id = uc.country_id)&quot;,
        columns(self = &quot;id&quot;, other = &quot;uc.user_id&quot;)
    ))]  
     countries2 : Vec&lt;Country&gt;
}

#[derive(Toql)]
struct UserCountry {

    #[toql(key)]
     user_id: u32,

    #[toql(key, join())] // Default joining on UserCountry.country_id = Country.id
     country: Country
     
}
#[derive(Toql)]
struct Country {

    #[toql(key)]
     id: String,

     name: Option&lt;String&gt;
}
#}</code></pre></pre>
<p>Wow, a lot going on here:</p>
<ul>
<li>
<p><code>countries1</code> merges on default column names (User.id = UserCountry.user_id).
Here the <code>Vec</code> contains <code>UserCountry</code>, which does not contain any interesting data and
is unconvenient when accessing <code>Country</code>.</p>
</li>
<li>
<p><code>countries2</code> skips the association table with a custom SQL join.
Let's look at <code>join_sql</code> first: The special other alias <code>...</code> refers - as always- to the merged struct (Country here),
so  <code>Country</code> will be joined with <code>UserCountry</code> on <code>Country.id = uc.country_id</code>.
After the select Toql merges the countries into the users on common column values of <code>User.id</code> and <code>uc.user_id</code> column value.
Because the later column is already aliased with <code>uc</code> no alias will be added.</p>
</li>
<li>
<p>In <code>UserCountry</code>, notice the nice example of a composite key made up with a join :)</p>
</li>
</ul>
<a class="header" href="#no-association-table-with-toqlforeign_key" id="no-association-table-with-toqlforeign_key"><h2>No association table with <code>#[toql(foreign_key)]</code></h2></a>
<p>In the example above <code>Country</code> knows nothing about the <code>User</code>, so we must merge with <code>join_sql</code>.</p>
<p>However sometimes the merged struct does have a suitable foreign key and we can apply a different pattern:</p>
<p>In the example below we don't have a classic association table.
Still we merge normally on <code>User.id</code> = <code>Todo.user_id</code>, but <code>Todo.user_id</code> is not part of a composite key, as it would be in a asscociation table. Instead it is just a normal foreign key.</p>
<p>This is not a problem when loading the merge. But when doing inserts,
Toql wishes to update <code>Todo.user_id</code> to ensure the foreign key contains the right value.
If <code>Todo.user_id</code> was part of the primary key this would work out of the box.
But since it's not, we have to mark it with <code>#[foreign_key]</code>. This tells to consider this column too when setting keys.</p>
<a class="header" href="#foreign-key-example" id="foreign-key-example"><h4>Foreign key example</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(auto_keys= true)]
struct User {
    #[toql(key)]
    id: u64,

    #[toql(merge())]
    todos: Vec&lt;UserTodo&gt;
}


#[derive(Toql)]
#[toql(auto_keys= true)]
struct Todo {
    #[toql(key)]
    id: u64,

    #[toql(foreign_key)]
    user_id: ,
    
    what: String
}
#}</code></pre></pre>
<a class="header" href="#keys" id="keys"><h1>Keys</h1></a>
<p>Toql requires you to add the attribute <code>key</code> to the field that correspond to the primary key in your database.</p>
<p>For composite keys mark multiple fields with the <code>key</code> attribute.</p>
<p>For internal reasons keys <strong>must always</strong> be</p>
<ul>
<li>the first fields in a struct</li>
<li>and must not be optional.</li>
</ul>
<p>This means that keys are preselected and therefore always loaded
when a Toql query selects fields from the struct.</p>
<a class="header" href="#example-2" id="example-2"><h4>Example:</h4></a>
<pre><code class="language-struct">#[derive(Toql)]
struct User {
  #[toql(key)]
    id: u64
    name: Option&lt;String&gt;
}
</code></pre>
<a class="header" href="#joins-2" id="joins-2"><h2>Joins</h2></a>
<p><em>Inner</em> joins can also have the <code>key</code> attribute. This is useful for association tables.</p>
<p>For a join used as a key the SQL builder takes the primary key of the joined struct to guess the foreign key columns.</p>
<a class="header" href="#example-3" id="example-3"><h4>Example:</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
#[derive(Toql)]
struct Language {

  #[toql(key)] 
  code: String,

  name: String
}

#[derive(Toql)]
struct UserLanguage {

  #[toql(key)] 
  user_id: u64

  #[toql(join(), key)]  
  language: Language; 
}
#}</code></pre></pre>
<p>For the example above Toql assumes that the database table <code>UserLanguage</code>  has a composite key made up of the two columns <code>user_id</code> and <code>language_code</code>. You can change this assumption, see <a href="4-derive/4-derive/4-joins.html">here</a>.</p>
<a class="header" href="#generated-key-struct" id="generated-key-struct"><h2>Generated key struct</h2></a>
<p>The Toql derive creates for every struct a corresponding key struct. The key struct contains only the fields marked as key form the derived stuct.</p>
<p>Keys are useful to :</p>
<ul>
<li>Delete a value with <code>delete_one</code>.</li>
<li>Build a <a href="4-derive/3-api/2-load.html">query</a>.</li>
<li>Update a <a href="4-derive/4-derive/4-joins.html">join</a>.</li>
</ul>
<p>Keys can be serialized and deserialized with serde, if the <code>serde</code> feature is eanbled.
This allows web clients to send either a full entity or just the key of it,
if they want to update some dependency.</p>
<a class="header" href="#example-4" id="example-4"><h4>Example</h4></a>
<pre><code>use crate::user::{User, UserKey};

let key = UserKey::from(10);
toql.delete_one(key).await?; // Convert 
</code></pre>
<a class="header" href="#unkeyable-fields" id="unkeyable-fields"><h2>Unkeyable fields</h2></a>
<p>Only columns and inner joins can be used as keys. Merged fields (<code>Vec&lt;T&gt;</code>) and fields that map to an Sql expression (<code>#[toql(sql=&quot;..&quot;)</code>) cannot be used as keys.</p>
<a class="header" href="#insert" id="insert"><h1>Insert</h1></a>
<p>When you insert a struct, all fields, including foreign keys of joins,  will be inserted.</p>
<p>Check <a href="4-derive/../3-api/4-insert.html">the api</a> for details.</p>
<a class="header" href="#default-values" id="default-values"><h2>Default values</h2></a>
<p>For <em>selectable</em> fields in a struct that are <code>None</code> Toql will insert the default value for the corresponding table column.
If you have not defined a default value in your database you must ensure that the field in the struct cannot be <code>None</code>.
This can be done through prior validation.</p>
<a class="header" href="#insert-behaviour" id="insert-behaviour"><h2>Insert behaviour</h2></a>
<p>The insert behaviour depends on the type amd mapping of a field:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
struct User {
    #[toql(key)]
    id: u64                     // Keys are never inserted
    
    username: String,		// Value
    realname: Option&lt;String&gt;,	// Default or value
    address: Option&lt;Option&lt;&lt;String&gt;&gt;,// Nullable column: Default, value or NULL

    #[toql(preselect)]
    info: Option&lt;String&gt; 	// Nullable column: Value or NULL

    #[toql(join)]
    address1: Option&lt;Address&gt; 	// Selectable inner Join: Foreign key is inserted or default

    #[toql(join)]
    address2: Option&lt;Option&lt;Address&gt;&gt;// Selectable left join: Default, value or NULL

    #[toql(join())]
    address3: Address 		// Inner Join: Foreign key or default

    #[toql(join(), preselect)]
    address4: Option&lt;Address&gt;&gt;	// Selectable inner join: Foreign key or default

    #[toql(merge())]
    phones1: Vec&lt;Phone&gt;&gt;		// No change on table 'User'

    #[toql(merge())]
    phones2: Option&lt;Vec&lt;Phone&gt;&gt;&gt; // No change on table 'User'
}
#}</code></pre></pre>
<p>When the path list requires to insert a dependency too,
left joins and optional merges will only be inserted, if they contains a value.</p>
<a class="header" href="#update" id="update"><h1>Update</h1></a>
<p>The update functions from the API will update a field,</p>
<ul>
<li>if the field name is in the field list</li>
<li>and a selectable field in the struct contains a value.</li>
</ul>
<a class="header" href="#update-behaviour-example" id="update-behaviour-example"><h4>Update behaviour example</h4></a>
<p>If we want to update all fields of the struct below with a field list of <code>*</code>, the behaviour would be</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
struct User {
    #[toql(key)]
    id: u64			// Keys are never updated	

    username: String,		// Update
    realname: Option&lt;String&gt;, 	// Updated , if Some
    address: Option&lt;Option&lt;&lt;String&gt;&gt;, // Update NULL or String, if Some

    #[toql(preselect)]
    info: Option&lt;String&gt;, 	//Update NULL or String

    #[toql(join)]
    address1: Option&lt;Address&gt;, // Update foreign_key, if Some 

    #[toql(join)]
    address2: Option&lt;Option&lt;Address&gt;&gt;,//  Update foreign_key or NULL, if Some 

    #[toql(join())]
    address3: Address, 		// Update foreign_key

    #[toql(join(), preselect)]
    address4: Option&lt;Address&gt;&gt;,	// Update foreign_key or NULL

    #[toql(merge())]
    phones1: Vec&lt;Phone&gt;&gt;,	// No effect for *

    #[toql(merge())]
    phones2: Option&lt;Vec&lt;Phone&gt;&gt;&gt; // No effect for *, 
}
#}</code></pre></pre>
<p>Notice that foreign keys of joins are included (<em>User.address1_id, User.address2_id, ..</em>) with the <code>*</code> in the field list.
However merges must be explicitly mentioned.</p>
<p>To update all fields from <code>User</code> and to resize the <code>Vec</code> of <code>phones1</code> (insert new phones + delete old phones ) the field list would be
<code>*, phones1</code>.</p>
<a class="header" href="#selections" id="selections"><h1>Selections</h1></a>
<p>Selections are a list of fields and can be defined on a struct.
A Toql query can then select the selection instead of all the individual fields. See <a href="../5-query-language/6-selections">here</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(selection(name=&quot;std&quot;, fields=&quot;*, address_street&quot;))]
#[toql(selection(name=&quot;tiny&quot;, fields=&quot;id, name&quot;))]
struct User {

 #[toql(key)]
 id: u64

 name: String

 #[toql(join())]
 address: Address

}

[derive(Toql)]
struct Address {

 #[toql(key)]
 id: u64

 street: String
#}</code></pre></pre>
<p>Notice that selection names with 3 letters or less are internally reserved and my have special meanings.
They can't be defined except <code>std</code> and <code>cnt</code>.</p>
<p>The selections above can now be used in a query. Instead of writing <code>name, address_street</code> it is possible to write <code>$std</code> or event just <code>$</code>.
(Because the standart selection is so common, <code>$</code> aliases to <code>$std</code>).</p>
<p>The <code>cnt</code> selection is defined in a similar way.TODO</p>
<a class="header" href="#predicates" id="predicates"><h1>Predicates</h1></a>
<p>All normal filtering is based on fields, <a href="4-derive/../5-query-language/4-filter.html">see here</a>.
However sometimes you may have a completely different filter criteria that can't be mapped on fields.</p>
<p>An example is the MySQL full text search. Let's do it:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(predicate(name=&quot;search&quot;, 
        sql=&quot;MATCH (..firstname, ..lastname) AGAINST (?  IN BOOLEAN MODE)&quot;))]

#[toql(predicate(name=&quot;street&quot;, 
        sql=&quot;EXISTS( SELECT 1 FROM User u JOIN Address a ON (u.address_id = a.id) \
            WHERE a.street = ? AND u.id = ..id)&quot;))]
struct User {

 #[toql(key)]
 id: u64,

 firstname: String,
 lastname: String,
}
#}</code></pre></pre>
<p>With the two predicates above you can seach for users that have a certain name with <code>@search 'peter'</code>
and retrieve all users from a certain street with <code>@street 'elmstreet'</code>.</p>
<p>The question marks in the predicate are replaced by the arguments provided.
If there is only one argument, it can also be used to build an <code>ON</code> predicate in a join. See <a href="4-derive/7-joins.html">on aux param</a>.</p>
<a class="header" href="#reference" id="reference"><h2>Reference</h2></a>
<p>The full predicate syntax is
<code>predicate(name=&quot;..&quot;, sql=&quot;..&quot;, handler=&quot;..&quot;, on_aux_param=&quot;..&quot;, count_filter=true|false)</code>
where</p>
<ul>
<li><strong>name</strong> is the name of the predicate. It can be called in a Toql query with <code>@name ..</code>.
If a predicate is defined on a joined struct, that predicate can be called with a path
<code>@path_name ..</code>. See <a href="4-derive/5-query-language/5-predictes.html">predicates in the query</a> for more details.</li>
<li><strong>sql</strong> is a raw QL expression. Use <code>?</code> to insert a predicate param in the SQL,
<code>..</code> for the table alias and <code>&lt;aux_param&gt;</code> for an aux param value.</li>
<li><strong>handler</strong> allows a custom predicate handler (build SQL with a function).
Provide a function name without parenthesis that return a struct that implement <code>toql::prelude::PredicateHandler</code></li>
<li><strong>on_aux_param</strong> sets the value of an aux_param. This aux param is only available when building custom joins
and can only be used when the predicate takes exactly one argument. See <a href="4-derive/7-join.html">example</a>.</li>
<li><strong>count_filter</strong> determines if a predicate used in Toql query should also be used for <a href="4-derive/3-api/2-load.html">count queries</a>.
Default is <code>false</code>.</li>
</ul>
<a class="header" href="#predicate-handlers" id="predicate-handlers"><h1>Predicate handlers</h1></a>
<p>It's also possible to write an own predicate handler.
Let's write a handler that concatenates all argument passed to the predicate and puts those arguments into the SQL predicate.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Toql)]
#[toql(predicate(name=&quot;names&quot;, 
                 sql=&quot;EXISTS (Select 1 FROM User u JOIN Todo t ON (u.id = t.user_id) \
                AND u.name IN &lt;args&gt;)&quot;, handler=&quot;my_handler&quot;))]
struct Todo {

 #[toql(key)]
 id: u64,

 what: String,
}


use toql::prelude::{PredicateHandler, SqlExpr, SqlArg, ParameterMap, SqlBuilderError};

pub(crate) struct MyPredicateHandler;
impl PredicateHandler for MyPredicateHandler {
    fn build_predicate(
        &amp;self,
        predicate: SqlExpr, 		// SQL from predicate
        predicate_args: &amp;[SqlArg],	// Arguments from the query
        aux_params: &amp;ParameterMap,	// Aux params
    ) -&gt; Result&lt;Option&lt;SqlExpr&gt;, SqlBuilderError&gt;  // Return None if no filtering should take place
    {
        if predicate_args.is_empty() {
            return Err(SqlBuilderError::FilterInvalid(
                &quot;at least 1 argument expected&quot;.to_string(),
            ));
        }
        let mut args_expr = SqlExpr::new();
        predicate_args.iter().for_each(|a| { 
            args_expr.push_arg(a.to_owned());
            args_expr.push_literal(&quot;, &quot;);
        });
        args_expr.pop(); // remove trailing ', '

        let mut replace = HashMap::new();
        replace.insert(&quot;args&quot;.to_string(), args_expr);
        let predicate = Resolver::replace_aux_params(predicate, &amp;replace); // Replace  aux params with SQL expressions
        
        Ok(Some(predicate))
    }
}

// Getter function
pub fn my_handler() -&gt; impl PredicateHandler {
    MyPredicateHandler {}
}

#}</code></pre></pre>
<p>Use it in a Toql query with <code>@names 'Peter' 'Sandy' 'Bob'</code></p>
<a class="header" href="#roles" id="roles"><h1>Roles</h1></a>
<p>It's possible to restrict access to fields and structs with boolean role expressions.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
#[derive(Toql)] {
#[toql(roles(insert=&quot;poweruser&quot;, delete=&quot;poweruser&quot;))
struct Book

    #[toql(key)]
    id : u64

    #[toql(roles(load=&quot;superuser;poweruser&quot;, update=&quot;poweruser&quot;))]
    rating: u64
}
#}</code></pre></pre>
<p>The role expressions are similar to the Toql query syntax:</p>
<ul>
<li>OR is expressed with ;</li>
<li>AND is expressed with ,</li>
<li>NOT is expressed with !</li>
<li>brackets are allowed</li>
</ul>
<p>An valid role expression would be <code>(teacher;student), !lazy</code> meaning <code>A teacher OR student AND NOT lazy</code>.</p>
<p>Roles are provided with the context:</p>
<pre><code>let mut r = HashSet::new();
r.insert(&quot;teacher&quot;);
let context = ContextBuilder::new()
        .with_roles(r)
        .build();
</code></pre>
<p>See <a href="4-derive/3-api/1-introduction.html">here</a> for how to get a backend.</p>
<p>Notice that roles can restrict access to columns but not to rows.
For row access control, check out the <a href="4-derive/../6-appendix/4-row-access-control.html">chapter</a> in the appendix.</p>
<a class="header" href="#toql-derive-reference" id="toql-derive-reference"><h1>Toql derive reference</h1></a>
<p>The derive provides struct level attributes and field level attributes. Here a list of all available attributes:</p>
<a class="header" href="#attributes-for-structs" id="attributes-for-structs"><h2>Attributes for structs</h2></a>
<table><thead><tr><th>Attribute </th><th> Description                             </th><th> Example / Remark</th></tr></thead><tbody>
<tr><td>tables  </td><td>   Table renaming scheme for struct and joins </td><td>  <code>CamelCase</code>, <code>snake_case</code>, <code>SHOUTY_SNAKE_CASE</code> or <code>mixedCase</code></td></tr>
<tr><td>columns        </td><td> Column renaming scheme </td></tr>
<tr><td>table </td><td> Table name for a struct or join </td><td> <code>table =&quot;User&quot;</code> on struct <code>NewUser</code> will access table <code>User</code></td></tr>
<tr><td>skip_mut </td><td>No code for insert, delete and update </td><td> struct cannot be updated</td></tr>
<tr><td>predicate </td><td>  Define a predicate </td><td> <code>predicate(name=&quot;test&quot;, sql=&quot;MATCH(..name, ..address) AGAINST (?)&quot;)</code></td></tr>
<tr><td>selection </td><td>  Define a selection </td><td> <code>selection(name=&quot;test&quot;, fields=&quot;*, address_street&quot;)</code></td></tr>
<tr><td>alias </td><td>Ignore calculated alias and use this alias instead</td><td> <code>alias=&quot;tb1&quot;</code></td></tr>
<tr><td>auto_key </td><td> Key is generated in database </td><td> <code>auto_key=true</code> Updates struct keys after inserts.</td></tr>
<tr><td>roles  </td><td>  role restriction for load, update, insert, delete </td><td> <code>roles(update=&quot;admin;teacher&quot;, insert=&quot;admin&quot;)</code></td></tr>
</tbody></table>
<a class="header" href="#attributes-for-fields" id="attributes-for-fields"><h2>Attributes for fields</h2></a>
<table><thead><tr><th>Attribute </th><th> Description </th><th> Example / Remark</th></tr></thead><tbody>
<tr><td>key</td><td> Primary key  </td><td>  For composite keys use multiple times. Skipped for insert, update.</td></tr>
<tr><td>column </td><td> column name </td><td> Use to overide default naming <code>column=&quot;UserNamE&quot;</code></td></tr>
<tr><td>sql </td><td> Map field to SQL expression </td><td> <code>sql=&quot;..title&quot;</code> or <code>sql=&quot;(SELECT o.name FROM Other o WHERE o.id = ..other_id)&quot;</code>, skipped for insert, update.</td></tr>
<tr><td>skip </td><td> Completly ignore field</td></tr>
<tr><td>skip_mut </td><td> Ignore for updating </td><td> Automatically added for keys and SQL expressions, add manually for db generated columns or safety restriction</td></tr>
<tr><td>skip_wildcard </td><td> Don't include this field in wildcard selection </td><td> Use for expensive subselects</td></tr>
<tr><td>join </td><td> Required for fields that join other structs  </td><td> <code>join(columns(self=&quot;address_id&quot;, other=&quot;id&quot;))</code></td></tr>
<tr><td>merge </td><td>Required for fields that are Vec&lt;&gt;  </td><td> <code>merge(columns(self=&quot;address_id&quot;, other=&quot;id&quot;))</code></td></tr>
<tr><td>handler </td><td> Build SQL expression with code </td><td> <code>handler=&quot;get_handler&quot;</code>, function returns struct implementing <code>toql::prelude::FieldHandler</code></td></tr>
<tr><td>aux_param</td><td> set aux_param </td><td> Use to give parameters to a field handler <code>aux_param(name=&quot;entity&quot;, value=&quot;USER&quot;)</code></td></tr>
<tr><td>roles </td><td>  role restriction for load, update </td><td>   <code>roles(load=&quot;admin&quot;)</code></td></tr>
<tr><td>foreign_key </td><td> The field is a foreign key. </td><td> Update that field too, if struct is joined. Rarely needed.</td></tr>
</tbody></table>
<a class="header" href="#the-query-language" id="the-query-language"><h1>The query language</h1></a>
<p>The Toql query language is a normal string that list all query fields, that should be retrieved from a database.</p>
<p>Besides selection, query fields can also be filtered and ordered.</p>
<p>They are separated either by comma or semicolon. If a filter is applied a comma will join the filters with AND, a semicolon with OR.</p>
<a class="header" href="#example-1" id="example-1"><h4>Example 1:</h4></a>
<pre><code>id, +name, age gt 18
</code></pre>
<p>is translated into</p>
<pre><code>SELECT t0.id, t0.name, t0.age FROM ... WHERE t0.age &gt; 18 ORDER BY t0.name ASC
</code></pre>
<a class="header" href="#example-2" id="example-2"><h4>Example 2:</h4></a>
<pre><code>id, .age eq 12; .age eq 15
</code></pre>
<p>is translated into</p>
<pre><code>SELECT t0.id From ... WHERE t0.age = 12 OR t0.age = 15
</code></pre>
<a class="header" href="#selecting-fields" id="selecting-fields"><h1>Selecting fields</h1></a>
<p>Fields are selected if they are mentioned in the query.</p>
<ul>
<li>
<p>Names without underscore represent typically columns or SQL expressions from the table the query is run against. <code>id, name, fullName, emailAddress</code></p>
</li>
<li>
<p>Fields with underscores are called <em>fields with a path</em>. They are mapped to a joined or a merged dependency. For a join relationship, the join will be added to the SQL statement if the field is selected. For a merge relationship a second SQL query is run and the results are merged. Such a query might look like this <code>book_id, book_title, book_createdBy_id, sellers_city</code></p>
</li>
</ul>
<a class="header" href="#example-5" id="example-5"><h4>Example</h4></a>
<pre><code>id, book_id
</code></pre>
<p>is translated into (SQL Mapper must be told how to join)</p>
<pre><code>SELECT a.id, b.id FROM User a JOIN Book b ON (a.book_id = b.id)
</code></pre>
<a class="header" href="#wildcards" id="wildcards"><h2>Wildcards</h2></a>
<p>There are two wildcards to select multiple fields. They can neither be filtered nor ordered.</p>
<ul>
<li>
<p><strong>*</strong> selects all fields from the top level.</p>
</li>
<li>
<p><strong><em>path_</em>*</strong> selects all fields from <em>path</em>.</p>
</li>
</ul>
<p>Fields can be excluded from the wildcard by setting them to <a href="5-query-language/../4-derive/reference.html"><code>skip_wildcard</code></a>.</p>
<p>So a query <code>*, book_*</code> would select all fields from user and book.</p>
<a class="header" href="#role-restricted-selection" id="role-restricted-selection"><h2>Role restricted selection</h2></a>
<p>Fields can require roles to be loaded.
An error is raised, if a query selects a field by name that it's not allowed to. However if the query
selects with a wildcard, the disallowed field will just be ignored.</p>
<a class="header" href="#ordering-fields" id="ordering-fields"><h1>Ordering fields</h1></a>
<p>Fields can be ordered in ascending <code>+</code> or descending <code>-</code> way.</p>
<a class="header" href="#example-6" id="example-6"><h4>Example</h4></a>
<p><code>+id, -title</code></p>
<p>is translated into</p>
<p><code>--snip-- ORDER BY id ASC, title DESC</code></p>
<a class="header" href="#ordering-priority" id="ordering-priority"><h2>Ordering priority</h2></a>
<p>Use numbers to express ordering priority.</p>
<ul>
<li>Lower numbers have higher priority.</li>
<li>If two fields have the same number the first field in the query has more importance.</li>
</ul>
<a class="header" href="#example-7" id="example-7"><h4>Example</h4></a>
<p><code>-2id, -1title, -2age</code></p>
<p>is translated into</p>
<p><code>--snip-- ORDER BY title DESC, id DESC, age DESC</code></p>
<a class="header" href="#filtering-fields" id="filtering-fields"><h1>Filtering fields</h1></a>
<p>Fields can be filtered by adding a filter to the field name.</p>
<ul>
<li>Filters are case insensitiv.</li>
<li>Arguments are separated by whitespace.</li>
<li>Strings and enum arguments are enclosed with single quotes.</li>
<li>Boolean arguments are expressed with numbers 0 and 1.</li>
</ul>
<p>To use a field only for filtering, but not for selection, hide it with a dot: <code>.age gt 50, .book_reviewed eq 1</code></p>
<a class="header" href="#example-8" id="example-8"><h4>Example</h4></a>
<pre><code>id, book_published eq 1, .age gt 50
</code></pre>
<p>is typically translated into (using canonical aliases)</p>
<pre><code>SELECT user.id, user_book.id, user_book.published FROM User user JOIN Book user_book ON (user.book_id = user_book.id) WHERE user_book.published = 1 AND  user.age &gt; 50
</code></pre>
<a class="header" href="#filter-operations" id="filter-operations"><h2>Filter operations</h2></a>
<table><thead><tr><th>Toql</th><th> Operation </th><th> Example </th><th> SQL</th></tr></thead><tbody>
<tr><td>eq </td><td> <em>equal</em>    </td><td>   age eq 50  </td><td> age = 50</td></tr>
<tr><td>eqn</td><td> <em>equal null</em>   </td><td>age eqn    </td><td>   age IS NULL</td></tr>
<tr><td>ne  </td><td> <em>not equal</em>   </td><td>name ne 'foo'  </td><td>name &lt;&gt; 'foo'</td></tr>
<tr><td>nen </td><td> <em>not equal null</em></td><td> age nen</td><td>    age IS NOT NULL</td></tr>
<tr><td>gt </td><td> <em>greater than</em> </td><td> age gt 16 </td><td> age &gt; 16com</td></tr>
<tr><td>ge </td><td> <em>greater than or equal</em> </td><td> age ge 16 </td><td> age &gt;= 16</td></tr>
<tr><td>lt </td><td> <em>less than</em> </td><td> age lt 16 </td><td> age &lt; 16</td></tr>
<tr><td>le </td><td> <em>less than or equal</em> </td><td> age le 16 </td><td> age &lt;= 16</td></tr>
<tr><td>bw </td><td> <em>between</em> </td><td> age bw 16 20 </td><td> age BETWEEN 16 AND 20</td></tr>
<tr><td>in </td><td> <em>includes</em> </td><td> name in 'Peter' 'Susan' </td><td> name in ('Peter, 'Susan')</td></tr>
<tr><td>out </td><td> <em>excludes</em> </td><td> age out 1 2 3 </td><td> name not in (1, 2, 3)</td></tr>
<tr><td>fn </td><td> <em>custom function</em> </td><td> search fn ma 'arg1' </td><td> <em>depends on implementation</em></td></tr>
</tbody></table>
<a class="header" href="#custom-functions" id="custom-functions"><h2>Custom functions</h2></a>
<p>Custom functions are applied through the <code>FN</code> filter. They must be handled by a Field Handler. See API for details.</p>
<a class="header" href="#joining-filters" id="joining-filters"><h2>Joining filters</h2></a>
<p>A field can be filtered multiple times by adding multiple the filter expressions in the query.</p>
<p>To build complex filter expressions join filters by comma to express logical AND or semicolon for logical OR.
Keep in mind that logical AND has higher precendence than logical OR.</p>
<p>Use parens if required:</p>
<pre><code class="language-toql">age eq 12, animal eq 'chicken'; animal eq 'cow
</code></pre>
<p>is the same as</p>
<pre><code class="language-toql">(age eq 12, animal eq 'chicken'); animal eq 'cow
</code></pre>
<p>but different than</p>
<pre><code class="language-toql">age eq 12, (animal eq 'chicken'; animal eq 'cow)
</code></pre>
<p>Use the dot notation if you only want to filter a field without selecting it:</p>
<pre><code class="language-toql">age eq 12, .animal eq 'chicken'; .animal eq 'cow'
</code></pre>
<a class="header" href="#argument-types" id="argument-types"><h2>Argument types</h2></a>
<p>Toql onyl knows integers, floats and strings. Use the following table to express more types:</p>
<table><thead><tr><th>Type</th><th> Toql Example </th><th>Remark</th></tr></thead><tbody>
<tr><td>bool</td><td> admin eq 1</td><td> 0, 1</td></tr>
<tr><td>integer</td><td> limit  bw -12 5</td><td> </td></tr>
<tr><td>float </td><td> price le 0.5e2</td><td> </td></tr>
<tr><td>string</td><td> name in 'peter'</td><td> Single quotes</td></tr>
<tr><td>date </td><td>subscribeUntil le '2050-12-31'</td><td>SQL format</td></tr>
<tr><td>time </td><td>start ge '08:30:00'</td><td> SQL format</td></tr>
<tr><td>date time </td><td>finishedAt ge '2005-12-31 08:30:00'</td><td> SQL format</td></tr>
</tbody></table>
<a class="header" href="#selections-1" id="selections-1"><h1>Selections</h1></a>
<p>A typical query selects a lot of fields. Instead of writing out a long list of fields, predefined field lists can be <a href="5-query-language/../3-api/9-selections.html">mapped</a>.</p>
<p>The list can then be selected with a <code>$</code> followed by the selection name.</p>
<pre><code class="language-toql">$mySelection, $otherSelection
</code></pre>
<p>There is a set of predefined selections:</p>
<table><thead><tr><th>Selection </th><th> Scope</th></tr></thead><tbody>
<tr><td> $std     </td><td> Standart selection, must be  to be used</td></tr>
<tr><td> $        </td><td> Alias for $std </td></tr>
<tr><td> $cnt     </td><td> Fields that are considered for a count query, defaults to keys and preselects</td></tr>
<tr><td> $all     </td><td> All fields on a struct, including dependencies</td></tr>
<tr><td> $mut     </td><td> All mutable fields on a struct</td></tr>
</tbody></table>
<p>Selections on a dependency can be used with a path.</p>
<p>To load the standart selection from a dependency <code>address</code> use</p>
<pre><code class="language-toql">$address_std
</code></pre>
<a class="header" href="#restriction-on-selection-names" id="restriction-on-selection-names"><h3>Restriction on selection names</h3></a>
<p>Selection names with 3 or less characters are reserved for internal purposes.
User defined selection names must contain at least 4 characters.</p>
<a class="header" href="#predicates-1" id="predicates-1"><h1>Predicates</h1></a>
<p>Normal query filters are applied to fields.
Predicates overcome this limitation and can filter on any raw SQL predicate.</p>
<p>The behaviour of predicates must be <a href="5-query-language/../4-derive/10-predicates.html">mapped</a>,
then they can be called with a <code>@</code>, the predicate name and zero or more arguments.</p>
<pre><code class="language-toql">@search 'peter', @updated, @tags 'island' 'fun'
</code></pre>
<p>Predicates can refer to a dependency, using a path.</p>
<p>To search a dependency <code>address</code> use</p>
<pre><code class="language-toql">@address_search 'peter'
</code></pre>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<p>The appendix is a wild collection of issues around Toql in no particular order.</p>
<a class="header" href="#mysql-enums" id="mysql-enums"><h1>MySQL Enums</h1></a>
<p>To map enums between a column and a struct field</p>
<ul>
<li>some MySQL boilerplate code is required.</li>
<li>the enum must implement the <code>ToString</code> and <code>FromStr</code> traits.</li>
</ul>
<p>For the first I made a little crate <a href="https://github.com/roy-ganz/mysql_enum">mysql_enum</a> and for the later several crates exit. Here an example with <a href="https://crates.io/crates/strum">strum</a>:</p>
<p>With this in Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
mysql_enum = &quot;0.1&quot;
strum = &quot;0.22&quot;
strum_macros = &quot;0.22&quot;
</code></pre>
<p>you can attribute your enums:</p>
<pre><code class="language-Rust">use mysql_enum::MysqlEnum;
use strum_macros::{Display, EnumString};

#[derive(PartialEq, EnumString, Display, MysqlEnum)]
enum Mood {
   Happy,
   Sad
} 
</code></pre>
<p>Now <em>Mood</em> can be used:</p>
<pre><code>#[derive (Debug, Toql)]
struct User {
    id : u64,
    name: Option&lt;string&gt;
    mood: Option&lt;Mood&gt;
}
</code></pre>
<a class="header" href="#row-access-control" id="row-access-control"><h1>Row access control</h1></a>
<p>Toql comes with role based access. Roles can only restrict access to columns but not to rows.
For a full security model you also need restricted access to rows.</p>
<p><strong>Row access control should always be done in databases.</strong></p>
<p>Reality is however that many databases (MySQL) provide little support for that.</p>
<p>So if you really need to do it in Toql, here is a way to go:</p>
<p>Let's assume a table <code>Todo</code>:</p>
<table><thead><tr><th>id </th><th> what </th><th> owner_id </th><th> done</th></tr></thead><tbody>
<tr><td>1 </td><td> Clean kitchen </td><td> 5 </td><td> 10%</td></tr>
<tr><td>2 </td><td> Take garbage out </td><td> 5 </td><td> 100%</td></tr>
<tr><td>3 </td><td> Go shopping </td><td> 2 </td><td> 50%</td></tr>
</tbody></table>
<p>and a <code>Permission</code> table:</p>
<table><thead><tr><th>entity </th><th> action </th><th> owner_only</th></tr></thead><tbody>
<tr><td>TODO </td><td> QUERY </td><td> true</td></tr>
<tr><td>TODO </td><td> UPDATE </td><td> true</td></tr>
</tbody></table>
<p>To ensure that a user with id 5 can only see his own rows 1 + 2 set up a permission field and
build a custom field handler. Like so</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
use toql::prelude::{FieldHandler, DefaultFieldHandler, 
    SqlExpr, ParameterMap, SqlBuilderError, SqlArg, sql_expr};

#[derive(Toql)]
#[toql(auto_key = true)]
struct Todo {
    #[toql(key)]
    id: u64,

    what: String, 

    #[toql(sql=&quot;&quot;, handler=&quot;permission_handler&quot;,  
            aux_param(name = &quot;entity&quot;, value = &quot;TODO&quot;))]
    permission: String
}

// Here comes our permission field handler
// We also want a custom filter function SC 
// so that we can filter for a specific permission.
//
// This allows the following toql queries
// Todos with any permissions -&gt; `*, permission ne ''` 
// Todos with UPDATE permission -&gt; `*, permission fn sc 'UPDATE'` 
struct PermissionFieldHandler{
     default_handler: defaultFieldHandler, // The default field handler gives us default filters, such as `ne`
};
    
impl FieldHandler for PermissionFieldHandler
{
    fn build_select(
        &amp;self,
        sql: SqlExpr,
        aux_params: &amp;ParameterMap,
    ) -&gt; Result&lt;Option&lt;SqlExpr&gt;, SqlBuilderError&gt; {
        
        // Get user_id from aux params (typically from web auth token)
        let user_id = aux_params.get(&quot;user_id&quot;).unwrap_or(&amp;SqlArg::Null);

        // Get entity from aux params (locally provided with permission handler)
        let entity = aux_params.get(&quot;entity&quot;).unwrap_or(&amp;SqlArg::Null).to_string();

        // Build subselect
        // Notice our special .. alias, it will be resolved later by the query builder
        // Build a string list with all permissions that we have as owners
        let sql = sql_expr!(&quot;(SELECT GROUP_CONCAT( p.action) FROM Permission p \
                WHERE p.entity = ? AND \
                (p.owner_only = false OR ..owner_id = ?))&quot;, entity, user_id);
        Ok(Some(sql))
    }
     fn build_filter(
        &amp;self,
        select: SqlExpr,
        filter: &amp;FieldFilter,
        aux_params: &amp;ParameterMap,
    ) -&gt; Result&lt;Option&lt;SqlExpr&gt;, SqlBuilderError&gt; {
        match filter {
            // Support our custom SC filter that maps to the MySQL FIND_IN_FIELD function
            FieldFilter::Fn(name, args) =&gt; match name.as_str() {
                &quot;SC&quot; =&gt; {
                    filter_sc(name, select, args)
                },
                name @ _ =&gt; Err(SqlBuilderError::FilterInvalid(name.to_string())),
            },
            _ =&gt; self.default_handler.build_filter(select, filter, aux_params),
        }
    }
}

pub fn filter_sc(
    name: &amp;str,
    select: SqlExpr,
    args: &amp;[SqlArg]
) -&gt; Result&lt;Option&lt;SqlExpr&gt;, SqlBuilderError&gt; {
    if args.len() != 1 {
        return Err(SqlBuilderError::FilterInvalid(
            &quot;filter `{}` expects exactly 1 argument&quot;,
            name
        )));
    }
            
    Ok(Some(sql_expr!(&quot;FIND_IN_SET (? , {})&quot;, args[0], select)))
}

// Getter fucntion for the mapper
pub fn permission_handler() -&gt; impl FieldHandler {
    PermissionFieldHandler:{
         default_handler: DefaultFieldHandler::new(), 
    }
}

#}</code></pre></pre>
<a class="header" href="#serde" id="serde"><h1>Serde</h1></a>
<p>Toql structs usually have a lot of <code>Option</code> types to make fields selectable with a query.
Let's look how to attribute them with serde for smooth interaction.</p>
<a class="header" href="#serializing" id="serializing"><h2>Serializing</h2></a>
<p>It's nice to omit unselected fields. This can easily achieved with <code>#[serde(skip_serializing_if = &quot;Option::is_none&quot;)]</code></p>
<a class="header" href="#serialize-example" id="serialize-example"><h3>Serialize example</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[serde(skip_serializing_if = &quot;Option::is_none&quot;)]
    age: Option&lt;u8&gt;

    #[serde(skip_serializing_if = &quot;Option::is_none&quot;)]
    address: Option&lt;Option&lt;Join&lt;Address&gt;&gt;&gt; // Selectable left join
#}</code></pre></pre>
<a class="header" href="#deserializing" id="deserializing"><h2>Deserializing</h2></a>
<p>Your server needs deserializing either</p>
<ul>
<li>when creating a new item</li>
<li>or when updating an existing item</li>
</ul>
<a class="header" href="#deserialize-example" id="deserialize-example"><h3>Deserialize example:</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[derive(Toql)]
    #[toql(auto_key = true)]
    struct User {
    
        // 'default' allows missing field 'id' in Json
        //  Needed typically for insert
        #[serde(default)] 
        #[toql(key)]
        id: u64
        
        // No Serde attribute:
        // Field must always be present in Json, but may be null -&gt; None
        name: Option&lt;String&gt;

        // Never deserialize expressions
        #[serde(skip_deserializing)]  
        #[toql(sql = &quot;(SELECT COUNT(*) From Book b WHERE b.author_id = ..id)&quot;)]
        pub number_of_books: Option&lt;u64&gt;,
    
        // See comment below
        #[serde(default, deserialize_with=&quot;des_double_option&quot;)]
        address: Option&lt;Option&lt;Join&lt;Address&gt;&gt;&gt; 
    }
#}</code></pre></pre>
<p>Notice the double <code>Option</code> on the selectable left join <code>address</code>.
When deserializing from JSON the following mapping works:</p>
<table><thead><tr><th>JSON </th><th> Rust</th></tr></thead><tbody>
<tr><td> undefined</td><td> None</td></tr>
<tr><td> null </td><td> Some(None)</td></tr>
<tr><td> value </td><td> Some(Some(value))</td></tr>
</tbody></table>
<p>To make this happen you need a custom deserialization function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use serde::{Deserializer, Deserialze};

pub fn des_double_option&lt;'de, T, D&gt;(de: D) -&gt; Result&lt;Option&lt;Option&lt;T&gt;&gt;, D::Error&gt;
where
    T: Deserialize&lt;'de&gt;,
    D: Deserializer&lt;'de&gt;,
{
    Deserialize::deserialize(de).map(Some)
}
#}</code></pre></pre>
<p>Now you get the following:</p>
<ul>
<li>If you omit address in your JSON <code>#[serde(default)]</code> kicks in and you get <code>None</code>.</li>
<li>If you send <code>&quot;addess&quot;: null</code>, you get <code>Some(None)</code>.</li>
<li>If you send <code>&quot;address: {&quot;id&quot;: 5}&quot;</code>, you get <code>Some(Some(Join::Key(AddressKey{id:5})))</code>.</li>
<li>If you send <code>&quot;address: {&quot;id&quot;: 5, ...}&quot;</code>, you get <code>Some(Some(Join::Entity(Address{id:5, ...})))</code>.</li>
</ul>
<p>Toql update will now work as expected.</p>
<a class="header" href="#debugging-toql" id="debugging-toql"><h1>Debugging Toql</h1></a>
<p>Toql generates a lot of code. Mostly from the <code>Toql</code> derive, but also from various macros, such as <code>query!</code>.</p>
<p>Th elibrary does not have any serious software tests and the test matrix is huge. So it may happen</p>
<ul>
<li>that you hit a bug.</li>
<li>the generated code doesn't compile.</li>
</ul>
<p>Or you just want to develop a new feature!</p>
<p>To debug Toql generated code, follow these steps:</p>
<ol>
<li>If you have a lot of modules move the affected <code>mod</code> at the end of the mod list. (So generated code will appear in the terminal last).</li>
<li>Run <code>cargo</code> with the logger enabled and a single job:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
 RUST_LOG=DEBUG cargo check --jobs=1
#}</code></pre></pre>
<ol start="3">
<li>Copy all the logged code from the derived struct and paste it into the source file.</li>
<li>Remove the log headers by regex replacing <code>\[2.*</code> with empty string. There should be 9 occurences.</li>
<li>Copy your derived struct.</li>
<li>Comment out your derived struct.</li>
<li>On the copied struct remove all references to Toql.</li>
<li>Format your document and debug!</li>
</ol>
<a class="header" href="#support" id="support"><h2>Support</h2></a>
<p>If you have issues with Toql you can post them on <a href="https://github.com/roy-ganz/toql/issues">GitHub</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
